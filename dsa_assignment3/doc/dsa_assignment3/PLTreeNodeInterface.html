<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (13.0.1) on Thu Feb 27 18:03:07 GMT 2020 -->
<title>PLTreeNodeInterface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2020-02-27">
<meta name="description" content="declaration: package: dsa_assignment3, interface: PLTreeNodeInterface">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/PLTreeNodeInterface.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">dsa_assignment3</a></div>
<h1 title="Interface PLTreeNodeInterface" class="title">Interface PLTreeNodeInterface</h1>
</div>
<div class="contentContainer">
<section class="description">
<hr>
<pre>public interface <span class="typeNameLabel">PLTreeNodeInterface</span></pre>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#applyVarBindings(java.util.Map)">applyVarBindings</a></span>&#8203;(java.util.Map&lt;dsa_assignment3.NodeType,&#8203;java.lang.Boolean&gt;&nbsp;bindings)</code></th>
<td class="colLast">
<div class="block">Applies a set of variable bindings recursively to the propositional logic
 expression represented by the current <code>PLTreeNode</code></div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>java.lang.Boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#evaluateConstantSubtrees()">evaluateConstantSubtrees</a></span>()</code></th>
<td class="colLast">
<div class="block">Evaluate the logical expression tree recursively, <strong>updating it in
 place</strong> to reduce constant sub-trees (i.e.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>dsa_assignment3.NodeType[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReversePolish()">getReversePolish</a></span>()</code></th>
<td class="colLast">
<div class="block">Produce the list of <code>NodeType</code> entries which, if provide to
 <code>reversePolishBuilder</code>, would construct the current tree</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeAndOrRightDeep()">makeAndOrRightDeep</a></span>()</code></th>
<td class="colLast">
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>W</code>, <code>X</code>, <code>Y</code> and <code>Z</code>, every
 occurrence of:
 
 <code>(Xâˆ¨Y)âˆ¨Z</code> with <code>Xâˆ¨(Yâˆ¨Z)</code>
 <code>(Xâˆ§Y)âˆ§Z</code> with <code>Xâˆ§(Yâˆ§Z)</code>
 
 This is the closest we can come in a binary tree representation to
 "flattening" the conjunctions and disjunctions as the last step in
 producing Conjunctive Normal Form.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushNotDown()">pushNotDown</a></span>()</code></th>
<td class="colLast">
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>x</code> and <code>y</code>, every occurrence of:
 
 <code>Â¬Â¬x</code> with <code>x</code>
 <code>Â¬(xâˆ¨y)</code> with <code>(Â¬xâˆ§Â¬y)</code>
 <code>Â¬(xâˆ§y)</code> with <code>(Â¬xâˆ¨Â¬y)</code>
 
 Be careful of handling cases such as <code>Â¬Â¬Â¬Â¬Â¬x</code> correctly (it
 should be reduced to <code>Â¬x</code>)</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushOrBelowAnd()">pushOrBelowAnd</a></span>()</code></th>
<td class="colLast">
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>x</code>, <code>y</code> and <code>z</code>, every occurrence of:
 
 <code>xâˆ¨(yâˆ§z)</code> with <code>(xâˆ¨y)âˆ§(xâˆ¨z)</code>
 <code>(xâˆ§y)âˆ¨z</code> with <code>(xâˆ¨z)âˆ§(yâˆ¨z)</code>
 
 This step is also knows as "distributing OR over AND"</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduceToCNF()">reduceToCNF</a></span>()</code></th>
<td class="colLast">
<div class="block">This takes the tree and executes all steps in
 the correct order to reduce it to Conjunctive Normal Form (CNF)
 
 Note that it does NOT call evaluateConstantSubtrees().</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceImplies()">replaceImplies</a></span>()</code></th>
<td class="colLast">
<div class="block">Recursively replace <strong>in place</strong> every occurrence of the
 pattern <code>xâ†’y</code> with <code>Â¬xâˆ¨y</code>, for sub-trees
 <code>x</code> and <code>y</code></div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Prints out the string in prefix notation.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toStringInfix()">toStringInfix</a></span>()</code></th>
<td class="colLast">
<div class="block">Prints out the string in infix notation.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toStringPrefix()">toStringPrefix</a></span>()</code></th>
<td class="colLast">
<div class="block">Prints out the string in prefix notation.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="getReversePolish()">getReversePolish</a></h3>
<div class="memberSignature"><span class="returnType">dsa_assignment3.NodeType[]</span>&nbsp;<span class="memberName">getReversePolish</span>()</div>
<div class="block">Produce the list of <code>NodeType</code> entries which, if provide to
 <code>reversePolishBuilder</code>, would construct the current tree</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>NodeType</code> array of the reverse polish notation
         specification of this tree</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="toString()">toString</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">toString</span>()</div>
<div class="block">Prints out the string in prefix notation. There should be no white space
 in the representation. Binary operators should use parentheses around
 their sub-expression. Unary operators should not.
 
 The <code>getInfixName()</code> method from <code>NodeType</code> should
 be used to get the name use for an <code>NodeType</code> operator, and
 the <code>getArity()</code> method to get the number of arguments that a
 <code>NodeType</code> operator takes.
 
 The following are examples of infix notations:
 
 <pre>
 ((Râˆ¨P)â†’(âŠ¤âˆ§Â¬Q))
 (Â¬(âŠ¥âˆ¨âŠ¤)âˆ¨(âŠ¤âˆ§Â¬Q))
 ((Â¬âŠ¥âˆ¨âŠ¤)âˆ§((Â¬âŠ¥âˆ¨Â¬Q)âˆ§((Â¬âŠ¤âˆ¨âŠ¤)âˆ§(Â¬âŠ¤âˆ¨Â¬Q))))
 </pre></div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the string representation of the tree rooted at this node in
         infix notation</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="toStringPrefix()">toStringPrefix</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">toStringPrefix</span>()</div>
<div class="block">Prints out the string in prefix notation. There should be no white space
 in the representation. Both unary and binary operators should use
 parentheses around their arguments:
 
 The <code>getPrefixName()</code> method from <code>NodeType</code> should
 be used to get the name use for an <code>NodeType</code> operator, and
 the <code>getArity()</code> method to get the number of arguments that a
 <code>NodeType</code> operator takes.
 
 The following are examples of prefix notation:
 
 <pre>
 implies(or(R,P),and(true,not(Q)))
 or(not(or(false,true)),and(true,not(Q)))
 and(or(not(false),true),and(or(not(false),not(Q)),and(or(not(true),true),or(not(true),not(Q)))))
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the string representation of the tree rooted at this node in
         prefix notation</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="toStringInfix()">toStringInfix</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">toStringInfix</span>()</div>
<div class="block">Prints out the string in infix notation. There should be no white space
 in the representation. Binary operators should use parentheses around
 their sub-expression. Unary operators should not.
 
 The <code>getInfixName()</code> method from <code>NodeType</code> should
 be used to get the name use for an <code>NodeType</code> operator, and
 the <code>getArity()</code> method to get the number of arguments that a
 <code>NodeType</code> operator takes.
 
 The following are examples of infix notations:
 
 <pre>
 ((Râˆ¨P)â†’(âŠ¤âˆ§Â¬Q))
 (Â¬(âŠ¥âˆ¨âŠ¤)âˆ¨(âŠ¤âˆ§Â¬Q))
 ((Â¬âŠ¥âˆ¨âŠ¤)âˆ§((Â¬âŠ¥âˆ¨Â¬Q)âˆ§((Â¬âŠ¤âˆ¨âŠ¤)âˆ§(Â¬âŠ¤âˆ¨Â¬Q))))
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the string representation of the tree rooted at this node in
         infix notation</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="applyVarBindings(java.util.Map)">applyVarBindings</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">applyVarBindings</span>&#8203;(<span class="arguments">java.util.Map&lt;dsa_assignment3.NodeType,&#8203;java.lang.Boolean&gt;&nbsp;bindings)</span></div>
<div class="block">Applies a set of variable bindings recursively to the propositional logic
 expression represented by the current <code>PLTreeNode</code>
 
 <p>
 This should <strong>update</strong> the tree rooted at the current node
 <strong>in place</strong> by replacing any variable in the tree
 (<code>NodeType.A</code> to <code>NodeType.A</code>) that also appears in
 <code>bindings</code> with either <code>NodeType.TRUE</code> or
 <code>NodeType.FALSE</code> depending on whether that variable is mapped
 to <code>true</code> or <code>false</code> respectively in
 <code>bindings</code>
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>bindings</code> - A map that maps <code>NodeType</code> objects to boolean
            values. Any variable in <code>bindings</code> that does not
            appear in the tree will be ignored. Any <code>NodeType</code>
            in <code>bindings</code> that is <strong>not</strong> a
            variable will be ignored</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="evaluateConstantSubtrees()">evaluateConstantSubtrees</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.Boolean</span>&nbsp;<span class="memberName">evaluateConstantSubtrees</span>()</div>
<div class="block">Evaluate the logical expression tree recursively, <strong>updating it in
 place</strong> to reduce constant sub-trees (i.e. those containing no
 variables) and make simplifications that do not require deep comparisons.
 <p>
 Thus <code>âŠ¥âˆ§A</code> should be reduced to <code>âŠ¥</code>, as it has to
 be <code>âŠ¥</code> no matter what value <code>A</code> takes.
 </p>
 Similarly <code>âŠ¥âˆ§(Aâˆ¨B)</code> should be reduced to <code>âŠ¥</code>, as it
 has to be <code>âŠ¥</code> no matter what value the right sub-expression
 <code>(Aâˆ¨B)</code> takes.
 <p>
 A further example: A tree that is the logical AND of one expression and
 the logical NOT of the same expression must be false. However, that can
 only be discovered by doing a deep comparison of the two sub-trees and
 therefore should not be done. A simple example of this is
 <code>Aâˆ§Â¬A</code>. In this case, although both sub-expressions are the
 same variable and are easy to compare, we should not make the evaluation
 to <code>âŠ¥</code> because we should not make comparisons that two
 sub-expressions are equal
 </p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if this tree evaluates to <code>true</code>,
         <code>false</code> if this tree evaluates to <code>false</code>
         and <code>null</code> if this tree cannot be fully evaluated to
         either <code>true</code> or <code>false</code> because of</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="reduceToCNF()">reduceToCNF</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">reduceToCNF</span>()</div>
<div class="block">This takes the tree and executes all steps in
 the correct order to reduce it to Conjunctive Normal Form (CNF)
 
 Note that it does NOT call evaluateConstantSubtrees(). This does not change the fact that
 the result is in CNF, it just means that it is perhaps larger than it need be. Feel free to call
 it at any time to simplify the results.
 
 Note that if you call the contained methods below in a different order, you are not guaranteed
 to end up with an expression in CNF</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="replaceImplies()">replaceImplies</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">replaceImplies</span>()</div>
<div class="block">Recursively replace <strong>in place</strong> every occurrence of the
 pattern <code>xâ†’y</code> with <code>Â¬xâˆ¨y</code>, for sub-trees
 <code>x</code> and <code>y</code></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pushNotDown()">pushNotDown</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">pushNotDown</span>()</div>
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>x</code> and <code>y</code>, every occurrence of:
 <ul>
 <li><code>Â¬Â¬x</code> with <code>x</code></li>
 <li><code>Â¬(xâˆ¨y)</code> with <code>(Â¬xâˆ§Â¬y)</code></li>
 <li><code>Â¬(xâˆ§y)</code> with <code>(Â¬xâˆ¨Â¬y)</code></li>
 </ul>
 Be careful of handling cases such as <code>Â¬Â¬Â¬Â¬Â¬x</code> correctly (it
 should be reduced to <code>Â¬x</code>)</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pushOrBelowAnd()">pushOrBelowAnd</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">pushOrBelowAnd</span>()</div>
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>x</code>, <code>y</code> and <code>z</code>, every occurrence of:
 <ul>
 <li><code>xâˆ¨(yâˆ§z)</code> with <code>(xâˆ¨y)âˆ§(xâˆ¨z)</code></li>
 <li><code>(xâˆ§y)âˆ¨z</code> with <code>(xâˆ¨z)âˆ§(yâˆ¨z)</code></li>
 </ul>
 This step is also knows as "distributing OR over AND"
 <p>
 Warning: since this requires replacing a pattern with one copy of a
 sub-tree with a different pattern with two copies of that sub-tree, and
 since these trees get modified in place, a <strong>deep copy</strong> of
 the sub-tree must be made so that the same actual sub-tree objects are
 not linked into from different places in the same tree
 </p></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeAndOrRightDeep()">makeAndOrRightDeep</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">makeAndOrRightDeep</span>()</div>
<div class="block">Recursively replace <strong>in place</strong>, for sub-trees
 <code>W</code>, <code>X</code>, <code>Y</code> and <code>Z</code>, every
 occurrence of:
 <ul>
 <li><code>(Xâˆ¨Y)âˆ¨Z</code> with <code>Xâˆ¨(Yâˆ¨Z)</code></li>
 <li><code>(Xâˆ§Y)âˆ§Z</code> with <code>Xâˆ§(Yâˆ§Z)</code></li>
 </ul>
 This is the closest we can come in a binary tree representation to
 "flattening" the conjunctions and disjunctions as the last step in
 producing Conjunctive Normal Form. The result is to turn complex trees of
 nested conjunctions into a simple right deep tree of conjunctions and
 similarly for disjunctions Thus this will change:
 <ul>
 <li><code>(Wâˆ¨X)âˆ¨(Yâˆ¨Z)</code> into <code>Wâˆ¨(Xâˆ¨(Yâˆ¨Z))</code></li>
 <li><code>((Wâˆ¨X)âˆ¨Y)âˆ¨Z</code> into <code>Wâˆ¨(Xâˆ¨(Yâˆ¨Z))</code></li>
 </ul></div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/PLTreeNodeInterface.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
